mutable and immutable

mutable =>
    Definition: Objects whose internal state can be changed.

    Examples: list, dict, set, bytearray

    Why mutable? Mutable objects have internal structures (such as arrays for lists or hash tables for dictionaries) that Python allows to be modified in place. This means you can change their contents without creating a new object. For example, you can add, remove, or modify elements in a list or dictionary.
    
    Use case: Mutables are useful when you need a data structure where you might want to change the content over time (e.g., appending elements to a list).

    code:
        my_list = [1, 2, 3]
        my_list.append(4)  # Modifies the list in place
        print(my_list)  # Output: [1, 2, 3, 4]


immutable =>
    Definition: Objects whose internal state cannot be changed after they are created.

    Examples: int, float, bool, tuple, str, frozenset
    
    Why immutable? Immutable objects are designed to be unchangeable. When you attempt to modify an immutable object, Python will create a new object in memory instead of modifying the original object. This behavior is essential for certain optimizations and consistency. For instance, immutable objects can be used as keys in dictionaries (mutables cannot, since their values could change and affect hash calculations).
    
    Use case: Immutables provide safety from unintentional changes and are particularly useful in multi-threaded environments where data consistency is critical.

    code:
        my_string = "hello"
        my_string = my_string + " world"  # A new string object is created
        print(my_string)  # Output: "hello world"

    
Why the distinction?
    Efficiency and optimization: Immutable objects, because they can't change, are often optimized for performance in Python. For instance, Python can cache small integers and strings.

    Data integrity: Immutability ensures that an object's state is consistent and won't change unexpectedly, which is crucial in cases like dictionary keys or elements of sets.
    
    Flexibility: Mutable objects allow for flexibility when working with large datasets, where in-place modification is efficient.
    
    

In short, mutables are mutable because they are designed to allow changes to their data, while immutables are immutable to ensure consistency, performance optimization, and integrity in certain use cases.
